import { createGame, CreateGameOptions } from 'src/core/game'
import * as t from 'src/core/types'

export type PublicGameLoopMethods = Awaited<
  ReturnType<typeof createGameLoop>
>['publicMethods']

export async function createGameLoop(gameOpts: CreateGameOptions) {
  const game = createGame(gameOpts)

  const controlledPlayers: Record<string, t.ControlledPlayer> = {}

  // TODO: implement turn skip on timeout
  async function loopUntilSuccess<ArgsT>(
    fn: () => Promise<void>,
    errCb?: (err: Error, ...args: ArgsT[]) => void
  ) {
    while (true) {
      // Try until the promise succeeds
      try {
        return await fn()
      } catch (e) {
        if (errCb) {
          errCb(e as Error)
        }
        continue
      }
    }
  }

  async function sendStateToEveryone() {
    await Promise.all(
      Object.keys(controlledPlayers).map((key) =>
        controlledPlayers[key as keyof typeof controlledPlayers].onStateChange(
          game.getState()
        )
      )
    )
  }

  async function start() {
    game.start()
    await sendStateToEveryone()
  }

  async function turn() {
    const player = game.whosTurn()
    console.log('turn by', player.name)
    await loopUntilSuccess(
      async () => {
        console.log('push by', player.name)
        const playerPush = await controlledPlayers[
          player.id as keyof typeof controlledPlayers
        ].getPush()
        game.pushByPlayer(player.id, playerPush.position)
      },
      (err) => console.warn('player push failed', err)
    )

    await loopUntilSuccess(
      async () => {
        console.log('move by', player.name)
        const moveTo = await controlledPlayers[
          player.id as keyof typeof controlledPlayers
        ].getMove()

        game.moveByPlayer(player.id, moveTo)
      },
      (err) => console.warn('player move failed', err)
    )

    await loopUntilSuccess(sendStateToEveryone, (err) =>
      console.warn('send state to everyone failed:', err)
    )
  }

  function getPublicState(): t.PublicGame {
    const { cards: _allGameCards, ...state } = game.getState()
    return {
      ...state,
      players: state.players.map(({ cards: _playerCards, ...p }) => {
        return {
          ...p,
          currentCards: game.getPlayersCurrentCards(p.id),
        }
      }),
    }
  }

  return {
    internal: {
      addPlayer: game.addPlayer,
    },
    public: {
      getPublicState,
      getMyPosition: () => ({ x: 0, y: 0 }),
      setMyDetails: ({ name }: Pick<t.Player, 'name'>) => undefined,
    },
    publicAdmin: {
      getState: game.getState,
      start,
    },
  }
}
